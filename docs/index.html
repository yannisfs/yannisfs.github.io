<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crystal Spikes Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- GSAP + ScrollTrigger (via CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/ScrollTrigger.min.js"></script>

  <!-- Quick CSS -->
  <style>
    /* Page Reset & Basic Layout */
    html, body {
      margin: 0; 
      padding: 0;
      height: 200vh; /* Some extra height to allow scrolling */
      font-family: sans-serif;
      background: #f5f5f5;
      position: relative;
      overflow-x: hidden; 
    }

    h1 {
      text-align: center;
      margin-top: 2rem;
    }

    /* Container for the crystals at the bottom */
    .crystal-container {
      position: fixed; /* Stays at bottom as user scrolls (could use absolute too) */
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50vh; /* Adjust as desired */
      pointer-events: none; /* so clicks pass through */
      z-index: -1; /* behind content */
      overflow: visible;
    }

    /* Make sure the SVG fills the container horizontally */
    #crystal-svg {
      display: block;
      width: 100%;
      height: 100%;
      /* "xMidYMax meet" ensures the bottom of the SVG aligns with bottom of the container */
      /* You might also try 'xMidYMax slice' or 'none' if you want to adjust scaling. */
    }
  </style>
</head>

<body>
  <h1>Scroll Down to See the Crystals Break Apart</h1>

  <!-- Some filler content for scrolling -->
  <div style="height: 150vh; padding: 2rem;">
    <p>Keep scrolling... the crystal spikes are at the bottom and will animate as you scroll!</p>
  </div>

  <!-- Container for our crystal SVG background -->
  <div class="crystal-container">
    <svg 
      id="crystal-svg" 
      viewBox="0 0 800 600" 
      preserveAspectRatio="xMidYMax meet"
    >
      <!-- A few polygon spikes resembling crystals. 
           Coordinates are chosen so that the base is near y=600 (the bottom).
           Feel free to customize shapes and colors. -->
      <polygon 
        id="crystal1"
        points="100,600 120,400 140,450 160,300 180,450 200,400 220,600"
        fill="#6CCFF6"
      />
      <polygon 
        id="crystal2"
        points="220,600 230,450 250,420 270,360 290,420 310,450 320,600"
        fill="#82E0AA"
      />
      <polygon
        id="crystal3"
        points="350,600 370,480 390,490 410,400 430,490 450,480 470,600"
        fill="#F7DC6F"
      />
      <polygon 
        id="crystal4"
        points="500,600 510,420 530,350 550,380 570,350 590,420 600,600"
        fill="#F1948A"
      />
      <polygon 
        id="crystal5"
        points="640,600 650,430 670,400 690,320 710,400 730,430 740,600"
        fill="#D7BDE2"
      />
    </svg>
  </div>

  <script>
    // Register plugins
    gsap.registerPlugin(ScrollTrigger);

    // We define an array of crystal IDs to animate
    const crystals = ["#crystal1", "#crystal2", "#crystal3", "#crystal4", "#crystal5"];

    // A timeline that triggers once the user starts scrolling
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: "body", // or a specific section
        start: "top top",  // animation starts at top of page
        end: "bottom bottom", // you can adjust to control how far the effect continues
        scrub: true,      // link the timeline progress to scroll
      }
    });

    // For each crystal, we do an upward movement + rotation + partial "break-apart" effect
    crystals.forEach((selector, i) => {
      // Random (or semi-random) transform offsets so they "break apart" uniquely
      const randX = gsap.utils.random(-40, 40);
      const randY = gsap.utils.random(-200, -350);
      const randRot = gsap.utils.random(-40, 40);

      // Add animation to the timeline
      tl.to(selector, {
        duration: 3,
        // We'll animate a few attributes:
        // 1) The "shape" itself can shift with 'attr' if we want, or we can transform the polygon
        // 2) We'll do a simple transform-based approach for better performance
        x: randX,
        y: randY,
        rotation: randRot,
        transformOrigin: "50% 100%", // pivot around the bottom center
        ease: "power2.inOut"
      }, 0); // Start them all together at timeline position 0
    });

    // Optionally, you can add a second step to fade them out or recolor
    // Example: At the end, they fade out
    tl.to(crystals, {
      duration: 2,
      opacity: 0,
      ease: "power1.out"
    }, ">-1"); // start this near the end
  </script>
</body>
</html>